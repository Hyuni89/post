[https://codingcompetitions.withgoogle.com/codejam/round/000000000087711b/0000000000accfdb](https://codingcompetitions.withgoogle.com/codejam/round/000000000087711b/0000000000accfdb)

---

## 내가 생각한 접근 방법

문제를 보자마자 DP로 풀 수 있겠다는 생각이 들었다. 하지만 어떤식으로 풀어야 할지는 조금 막막했다. 결국 직접 몇가지 케이스를 적어보며 핵심 원리를 찾아갔다.

> 가장 최소한의 방법은 정렬된 상태에서 한쪽 방향으로 증가하거나 감소할 때이다.

10의 압력에서 이전 사람의 모든 공에 바람이 불어 넣어졌고, 20, 50, 60의 압력을 불어넣어야 한다고 하면 10 -> 20 -> 50 -> 60이 10 + 30 + 10 = 50으로 최솟값이 된다. 혹은 다음 사람의 압력 수요를 고려하여 10 -> 60 -> 50 -> 20이 50 + 10 + 30 = 90으로 작은 값이 된다. 10 -> 50 -> 20 -> 60이나 10 -> 50 -> 60 -> 20은 불필요한 횟수가 더해지게 된다.

계산하기 편하게 각 압력이 정렬된 상태로 있고, 각 압력에 도달하기까지의 눌림 횟수와 다음 시작 압력까지의 합의 최소값, 그리고 다음 압력 눌림의 여러 가지 케이스의 최솟값을 계산하면 될 것 같았다. 이렇게 적으면서도 무슨말인지 모를정도로 명확하게 점화식이 세워지지 않았다. 

예제의 입력을 예로 들어 설명하면,

| 10      이곳이 마지막 압력이 되려면   40 + 10 + 20 = 70 | 30      이곳이 마지막 압력이 되려면   min(10 + 30 + 10, 40 + 30 + 20) = 50 | 40      이곳이 마지막 압력이 되려면   40 |
| --- | --- | --- |
| 20      이전 각 압력에서 이 압력으로 오려면   min(70 + 10, 50 + 10, 40 + 20) = 60      이곳이 마지막 압력이 되려면   60(맨 오른쪽의) + 10 + 30 = 100 | 50      이전 각 압력에서 이 압력으로 오려면   min(70 + 40, 50 + 20, 40 + 10) = 50      이곳이 마지막 압력이 되려면   min(60 + 40 + 30, 60 + 40 + 10) = 110 | 60      이전 각 압력에서 이 압력으로 오려면   min(70 + 50, 50 + 30, 40 + 20) = 60      이곳이 마지막 압력이 되려면   60(맨 왼쪽의) + 30 + 10 = 100 |
| 50      이전 각 압력에서 이 압력으로 오려면   min(100 + 30, 110 + 0, 100 + 10) = 110      이곳이 마지막 압력이 되려면   100 + 10 = 110 | 60      이전 각 압력에서 이 압력으로 오려면   min(100 + 40, 110 + 10, 100 + 0) = 100      이곳이 마지막 압력이 되려면   min(110 + 10, 100 + 10) = 110 | 60      이전 각 압력에서 이 압력으로 오려면   min(100 + 40, 110 + 10, 100 + 0) = 100      이곳이 마지막 압력이 되려면   110 + 10 = 120 |

신기하게 정답이 나오는 것 같아서 이대로 코드를 짰다.

```python
import sys

input = sys.stdin.readline

t = int(input())
for tcase in range(t):
	n, p = map(int, input().split())
	arr = [sorted(list(map(int, input().split()))) for _ in range(n)]
	reg = [[0] * p for _ in range(n)]
    
	for i in range(p):
		reg[0][i] = arr[0][-1] * 2 - arr[0][i]
    
	for i in range(1, n):
		last = [10 ** 14] * p
		for j in range(p):
			for k in range(p):
				last[j] = min(last[j], reg[i - 1][k] + abs(arr[i - 1][k] - arr[i][j]))
		for j in range(p):
			reg[i][j] = min(last[0] + arr[i][-1] * 2 - arr[i][j] - arr[i][0], last[-1] + arr[i][-1] + arr[i][j] - arr[i][0] * 2)
    
	ans = min(reg[-1])

	print(f"Case #{tcase + 1}: {ans}")
```

결과는 Test Set 1은 pass, Test Set 2는 TLE. O(t \* n \* p \* p) = O(100 \* 1000 \* 100 \* 100) = O(1,000,000,000) 이기에 괜찮을줄 알았는데 전혀 아니었다.

---

## 문제를 푸는 방법

조금만 여유를 가지고 생각했으면 문제를 푸는데 도움이 되는 핵심적인 내용을 더 찾을 수 있었을 것이다.

> 가장 최소한의 방법은 정렬된 상태에서 한쪽 방향으로 증가하거나 감소할 때이다.

한 사람이 가지고 있는 공의 압력을 모두 채울때 최소한 Max - Min의 값이 필요하다.

> 이전 압력이 중간에 위치하더라도 한쪽 방향으로 증가하거나 감소할 때에 최소값이 유효하다.

모든 공에 압력을 채워야 하므로 최소 압력과 최대 압력은 모두 거쳐야 한다. 그러므로 이전 압력을 l이라고 하면 l + (l - Min) + (Max - Min)이거나 l + (Max - l) + (Max - Min)이 되고, l - Min이나 Max - l이 최소값이 되어야한다.

> 모든 케이스에서 한쪽 방향으로 증가하거나 감소하는 방향으로 압력을 넣거나 뺀다고 가정하면 이전 항에서는 항상 압력이 가장 크거나 작은 상태일 것이다.

위의 원리를 가지고 점화식을 세울수 있게 된다.

각 라운드를 R이라고 하고 마지막 압력을 l, 가장 낮은 압력을 0, 높은 압력을 1이라고 가정하면,

> R(i + 1, 0) = min(R(i, 0) + |l0 - Min| + Max - Min, R(i, 1) + |l1 - Min| + Max - Min))  
> R(i + 1, 1) = min(R(i, 0) + |l0 - Max| + Max - Min, R(i, 1) + |l1 - Max| + Max - Min))

이렇게 표현 할 수 있고, 점화식이 세워지면 코드는 그냥 점화식 따라서 짜면 된다.

```python
import sys

input = sys.stdin.readline

t = int(input())
for tcase in range(t):
	n, p = map(int, input().split())
	arr = [sorted(list(map(int, input().split()))) for _ in range(n)]
	reg = [[0] * 2 for _ in range(n + 1)]
	l0 = l1 = 0
    
	for i in range(1, n + 1):
		reg[i][0] = min(reg[i - 1][0] + abs(l0 - arr[i - 1][0]) + arr[i - 1][-1] - arr[i - 1][0],
                        reg[i - 1][1] + abs(l1 - arr[i - 1][0]) + arr[i - 1][-1] - arr[i - 1][0])
		reg[i][1] = min(reg[i - 1][0] + abs(l0 - arr[i - 1][-1]) + arr[i - 1][-1] - arr[i - 1][0],
                        reg[i - 1][1] + abs(l1 - arr[i - 1][-1]) + arr[i - 1][-1] - arr[i - 1][0])
		l0 = arr[i - 1][-1]
		l1 = arr[i - 1][0]
    
	print(f"Case #{tcase + 1}: {min(reg[n])}")
```